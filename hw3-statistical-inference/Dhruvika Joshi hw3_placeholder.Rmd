title: "Homework 3 - Customer Segmentation"
output: html_document
---

```{r setup, include=FALSE}

library(tidyverse)
library(lubridate)
library(cluster)
library(factoextra)
library(ggcorrplot)
library(gridExtra)
install.packages("ggpubr")  # needed for fviz functions
sknitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)


# optional global settings for cleaner output
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
install.packages("corrplot")


```

## Data Import

```{r data-import}
data_url <- "https://www.dropbox.com/scl/fi/pv3fw2158cv7fwkr3sijb/customer_segmentation.csv?rlkey=65xq0l6nlykhd3ks5ne24ij7l&st=vnklkaxk&dl=1"
customers <- read_csv(data_url, show_col_types = FALSE)
cat("Dataset loaded successfully\n")
cat("Rows:", nrow(customers), "\n")
cat("Columns:", ncol(customers), "\n")
```

## 1. Data Cleaning & Preparation

```{r section-1}

# Check what columns actually exist
cat("\n=== CHECKING ACTUAL COLUMN NAMES ===\n")
print(names(customers))

# Check structure
str(customers)
cat("=== DATA CLEANING & PREPARATION ===\n\n")

cat("=== DATA CLEANING & PREPARATION ===\n\n")

# Inspect data structure and missing values
cat("1. Initial Data Inspection:\n")
cat("   - Dataset dimensions:", nrow(customers), "rows,", ncol(customers), "columns\n")

# First, let's see what columns we actually have
cat("\n   Checking actual column names in dataset...\n")
cat("   Columns:", paste(names(customers), collapse = ", "), "\n\n")

# Check structure
glimpse(customers)

missing_counts <- customers %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Missing") %>%
  filter(Missing > 0)

if(nrow(missing_counts) > 0) {
  cat("\n   - Variables with missing values:\n")
  print(missing_counts)
} else {
  cat("\n   - No missing values detected\n")
}

# Check for duplicates
duplicates <- sum(duplicated(customers$ID))
cat("\n2. Duplicate Check:\n")
cat("   - Duplicate IDs found:", duplicates, "\n")

if(duplicates > 0) {
  customers <- customers %>% distinct(ID, .keep_all = TRUE)
  cat("   - Duplicates removed\n")
}

# Remove constant columns
cat("\n3. Removing Constant Columns:\n")
constant_cols <- c("Z_CostContact", "Z_Revenue")
customers <- customers %>% select(-any_of(constant_cols))
cat("   - Removed:", paste(constant_cols[constant_cols %in% names(customers)], collapse = ", "), "\n")

# Handle missing income values
cat("\n4. Handling Missing Values:\n")

# Calculate median of income
median_income <- median(customers$income, na.rm = TRUE)
missing_income <- sum(is.na(customers$income))

# Replace missing values with median
customers <- customers %>%
  mutate(income = ifelse(is.na(income), median_income, income))

cat(" - Imputed", missing_income, "missing income values with median ($",
    round(median_income), ")\n", sep = "")


# Parse dates and create Tenure variable
cat("\n5. Date Processing and Tenure Calculation:\n")

customers <- customers %>%
  mutate(
    dt_customer = dmy(dt_customer),
    tenure = as.numeric(difftime(Sys.Date(), dt_customer, units = "days")) / 365.25
  )

cat(" - Parsed customer enrollment dates\n")
cat(" - Created Tenure variable (years as customer)\n")

# Create Age variable and filter unrealistic values
cat("\n6. Age Calculation and Outlier Removal:\n")

current_year <- year(Sys.Date())

customers <- customers %>%
  mutate(Age = current_year - year_birth) %>%
  filter(Age <= 100)

cat(" - Created Age variable\n")
cat(" - Removed customers with Age > 100\n")
cat(" - Remaining customers:", nrow(customers), "\n")


cat("   - Created Age variable\n")
cat("   - Removed customers with Age > 100\n")
cat("   - Remaining customers:", nrow(customers), "\n")

# Consolidate categorical variables
cat("\n7. Consolidating Categorical Variables:\n")
customers <- customers %>%
  mutate(
    marital_status = case_when(
      marital_status %in% c("Married", "Together") ~ "Partnered",
      marital_status %in% c("Divorced", "Widow", "Alone", "Separated", "Absurd", "YOLO", "Single") ~ "Single/Other",
      TRUE ~ marital_status
    ),
    education = case_when(
      education %in% c("Basic", "2n Cycle") ~ "Basic/Secondary",
      education == "Graduation" ~ "Undergraduate",
      education %in% c("Master", "PhD") ~ "Postgraduate",
      TRUE ~ education
    )
  )

cat("   - Consolidated Marital_Status into 2 categories\n")
cat("   - Standardized Education into 3 levels\n")

# Engineer new features
cat("\n8. Feature Engineering:\n")

# Check what columns are available for feature engineering
cat("   Checking available columns for feature engineering...\n")

# Spending variables
spend_cols <- c("MntWines", "MntFruits", "MntMeatProducts", 
                "MntFishProducts", "MntSweetProducts", "MntGoldProds")
available_spend_cols <- spend_cols[spend_cols %in% names(customers)]

# Purchase variables
purchase_cols <- c("NumDealsPurchases", "NumWebPurchases", 
                   "NumCatalogPurchases", "NumStorePurchases")
available_purchase_cols <- purchase_cols[purchase_cols %in% names(customers)]

# Check if kids columns exist
has_kids_cols <- all(c("Kidhome", "Teenhome") %in% names(customers))

cat("   - Found", length(available_spend_cols), "spending columns\n")
cat("   - Found", length(available_purchase_cols), "purchase columns\n")
cat("   - Kids/teens columns available:", has_kids_cols, "\n")

# Create features based on available columns
if(length(available_spend_cols) > 0) {
  customers <- customers %>%
    mutate(
      # Total spending across all categories
      TotalSpend = rowSums(across(all_of(available_spend_cols)), na.rm = TRUE),
      
      # Total number of purchases
      TotalPurchases = if(length(available_purchase_cols) > 0) {
        rowSums(across(all_of(available_purchase_cols)), na.rm = TRUE)
      } else {
        0
      },
      
      # Number of children in household
      NumChildren = if(has_kids_cols) {
        Kidhome + Teenhome
      } else {
        0
      },
      
      # Household size (adults + children)
      HouseholdSize = case_when(
        has_kids_cols & Marital_Status == "Partnered" ~ 2 + Kidhome + Teenhome,
        has_kids_cols ~ 1 + Kidhome + Teenhome,
        Marital_Status == "Partnered" ~ 2,
        TRUE ~ 1
      ),
      
      # Average spend per purchase
      AvgSpendPerPurchase = ifelse(TotalPurchases > 0, 
                                    TotalSpend / TotalPurchases, 0)
    )
  
  cat("   - TotalSpend: Sum of all product category spending\n")
  cat("   - TotalPurchases: Total transaction count\n")
  cat("   - NumChildren: Combined kids and teens at home\n")
  cat("   - HouseholdSize: Total household members\n")
  cat("   - AvgSpendPerPurchase: Basket size metric\n")
} else {
  cat("   WARNING: Spending columns not found! Cannot create TotalSpend.\n")
  cat("   Available columns are:\n")
  print(names(customers))
}

# Final summary
cat("\n9. Cleaned Dataset Summary:\n")
cat("   - Final dataset:", nrow(customers), "rows,", ncol(customers), "columns\n")
cat("   - Missing values remaining:", sum(is.na(customers)), "\n")

# Display key statistics - check which variables exist first
cat("\n=== KEY VARIABLE STATISTICS ===\n")

# List of desired variables
desired_vars <- c("Age", "Income", "Tenure", "NumChildren", "HouseholdSize", 
                  "TotalSpend", "TotalPurchases", "AvgSpendPerPurchase")

# Check which ones actually exist
available_vars <- desired_vars[desired_vars %in% names(customers)]

if(length(available_vars) > 0) {
  customers %>%
    select(all_of(available_vars)) %>%
    summary() %>%
    print()
} else {
  cat("WARNING: None of the expected variables were created.\n")
  cat("Here are the first 10 columns of your dataset:\n")
  customers %>%
    select(1:min(10, ncol(customers))) %>%
    summary() %>%
    print()
}

```
## 2. Exploratory Data Analysis

```{r section-2}
## Exploratory Data Analysis (EDA)

colnames(customers)

## 2. Exploratory Data Analysis


# --- Descriptive Statistics ---
customers %>%
  select(income, age, total_spend, total_purchases, tenure) %>%
  summary()

# --- Correlation Matrix ---
key_vars <- customers %>%
  select(income, age, total_spend, total_purchases, tenure)

cor_matrix <- cor(key_vars, use = "pairwise.complete.obs")

# --- Visualize Correlations ---
ggcorrplot(cor_matrix,
           lab = TRUE,
           title = "Correlation Matrix (Key Variables)",
           lab_size = 3,
           type = "lower",
           colors = c("blue", "white", "red"))

# --- Income Distribution ---
cutoff <- quantile(customers$income, 0.99, na.rm = TRUE)

customers %>%
  filter(income <= cutoff) %>%
  ggplot(aes(x = income)) +
  geom_histogram(fill = "skyblue", color = "white", bins = 40) +
  scale_x_continuous(labels = scales::comma) +
  labs(title = "Income Distribution (Below 99th Percentile)",
       x = "Income",
       y = "Count") +
  theme_minimal()

# --- Age Distribution ---
customers %>%
  ggplot(aes(x = age)) +
  geom_histogram(fill = "lightgreen", color = "white", bins = 30) +
  labs(title = "Age Distribution", x = "Age", y = "Count") +
  theme_minimal()

# --- Total Spend Distribution ---
customers %>%
  ggplot(aes(x = total_spend)) +
  geom_histogram(fill = "lightcoral", color = "white", bins = 30) +
  labs(title = "Total Spend Distribution", x = "Total Spend", y = "Count") +
  theme_minimal()

# --- Total Purchases Distribution ---
customers %>%
  ggplot(aes(x = total_purchases)) +
  geom_histogram(fill = "orchid", color = "white", bins = 30) +
  labs(title = "Total Purchases Distribution", x = "Total Purchases", y = "Count") +
  theme_minimal()

# --- Boxplots for Outlier Detection ---
# Income
customers %>%
  ggplot(aes(y = income)) +
  geom_boxplot(fill = "skyblue", color = "black") +
  scale_y_continuous(labels = scales::comma) +
  labs(title = "Income Distribution (Boxplot)", y = "Income") +
  theme_minimal()

# Age
customers %>%
  ggplot(aes(y = age)) +
  geom_boxplot(fill = "lightgreen", color = "black") +
  labs(title = "Age Distribution (Boxplot)", y = "Age") +
  theme_minimal()

# Total Spend
customers %>%
  ggplot(aes(y = total_spend)) +
  geom_boxplot(fill = "lightcoral", color = "black") +
  labs(title = "Total Spend Distribution (Boxplot)", y = "Total Spend") +
  theme_minimal()

# Total Purchases
customers %>%
  ggplot(aes(y = total_purchases)) +
  geom_boxplot(fill = "orchid", color = "black") +
  labs(title = "Total Purchases Distribution (Boxplot)", y = "Total Purchases") +
  theme_minimal()

# --- Findings ---
cat("## Key Insights from EDA:\n")
cat("- Income centers around $50K–$70K after trimming outliers, with a few very high-income customers remaining.\n")
cat("- Age follows a near-normal distribution, mostly concentrated between 40–60 years.\n")
cat("- Total Spend and Total Purchases are right-skewed — many low-spending customers, few heavy buyers.\n")
cat("- Total Spend and Total Purchases are highly correlated (r ≈ 0.75) — one may be excluded from clustering.\n")
cat("- Income is moderately correlated with spending and purchases, showing wealthier customers tend to spend more.\n")
cat("- Tenure has little correlation with other variables, suggesting customer longevity doesn’t drive higher spend.\n")
cat("- Outliers appear mainly in Income and Total Spend, highlighting the need for scaling before clustering.\n")

```

## 3. Clustering

```{r section-3}

## 3. Clustering

# --- Check for missing values in clustering variables ---
cat("Checking missing values in clustering variables:\n")
cluster_vars <- customers %>%
  select(income, age, tenure, num_children, total_spend)

cat("Missing values per column:\n")
print(colSums(is.na(cluster_vars)))
cat("\nTotal rows:", nrow(cluster_vars), "\n")
cat("Rows with ANY missing values:", sum(!complete.cases(cluster_vars)), "\n")
cat("Rows with NO missing values:", sum(complete.cases(cluster_vars)), "\n")

# --- Use only complete cases ---
cluster_df <- cluster_vars %>% 
  filter(complete.cases(.))

cat("\nRows after removing NAs:", nrow(cluster_df), "\n")

# If we have too few rows, let's check the original data
if(nrow(cluster_df) < 10) {
  cat("\nWARNING: Very few complete cases. Checking individual columns:\n")
  cat("Income NAs:", sum(is.na(customers$income)), "\n")
  cat("Age NAs:", sum(is.na(customers$age)), "\n")
  cat("Tenure NAs:", sum(is.na(customers$tenure)), "\n")
  cat("NumChildren NAs:", sum(is.na(customers$num_children)), "\n")
  cat("TotalSpend NAs:", sum(is.na(customers$total_spend)), "\n")
  
  cat("\nTrying with just income, age, and total_spend:\n")
  cluster_df <- customers %>%
    select(income, age, total_spend) %>%
    filter(complete.cases(.))
  
  cat("Rows with complete income, age, total_spend:", nrow(cluster_df), "\n")
}

# Only proceed if we have enough data
if(nrow(cluster_df) >= 10) {
  
  # --- Scaling Features ---
  cluster_scaled <- cluster_df %>% 
    mutate(across(everything(), scale)) %>%
    as.data.frame()
  
  # --- Elbow Method for Choosing Optimal k ---
  set.seed(123)
  
  # Limit max clusters to number of rows
  max_k <- min(10, nrow(cluster_scaled))
  
  wss <- sapply(1:max_k, function(k) {
    kmeans(cluster_scaled, centers = k, nstart = 25)$tot.withinss
  })
  
  # Plot elbow curve
  plot(1:max_k, wss, type = "b", pch = 19,
       xlab = "Number of Clusters (k)",
       ylab = "Within-Cluster Sum of Squares",
       main = "Elbow Method for Optimal k")
  
  # --- Run K-Means with Chosen k ---
  k <- min(4, max_k)  # Use 4 or less if not enough data
  set.seed(123)
  kmeans_result <- kmeans(cluster_scaled, centers = k, nstart = 25)
  
  # Add cluster assignments
  cluster_df$cluster <- as.factor(kmeans_result$cluster)
  
  # --- Display Cluster Sizes ---
  cat("\nCluster Sizes:\n")
  print(table(kmeans_result$cluster))
  
  # --- Display Cluster Centers ---
  cat("\nCluster Centers (original scale):\n")
  cluster_centers <- cluster_df %>%
    mutate(cluster = as.factor(kmeans_result$cluster)) %>%
    group_by(cluster) %>%
    summarise(across(everything(), mean, .names = "avg_{.col}"), 
              count = n())
  print(cluster_centers)
  
  # --- Visualize Clusters ---
  library(ggplot2)
  
  # Check which variables we have
  if("total_spend" %in% names(cluster_df) && "income" %in% names(cluster_df)) {
    p1 <- ggplot(cluster_df, aes(x = income, y = total_spend, color = cluster)) +
      geom_point(size = 2, alpha = 0.6) +
      labs(title = "Customer Segments: Income vs Total Spend",
           x = "Income ($)", y = "Total Spend ($)", color = "Cluster") +
      scale_x_continuous(labels = scales::comma) +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal()
    print(p1)
  }
  
  if("total_spend" %in% names(cluster_df) && "age" %in% names(cluster_df)) {
    p2 <- ggplot(cluster_df, aes(x = age, y = total_spend, color = cluster)) +
      geom_point(size = 2, alpha = 0.6) +
      labs(title = "Customer Segments: Age vs Total Spend",
           x = "Age (years)", y = "Total Spend ($)", color = "Cluster") +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal()
    print(p2)
  }
  
} else {
  cat("\nERROR: Not enough complete cases for clustering.\n")
  cat("Please check your data processing steps.\n")
}
```

## 4. PCA and Visualization

```{r section-4}
## 4. Dimensionality Reduction (PCA) and Cluster Visualization

# Running PCA on scaled clustering variables
pca_res <- prcomp(cluster_scaled, center = TRUE, scale. = TRUE)

# Reporting proportion of variance explained by first two principal components
summary(pca_res)$importance[2, 1:2]   # Proportion of variance explained
summary(pca_res)$importance[3, 1:2]   # Cumulative variance explained

# Extracting PCA loadings (contribution of each variable)
loadings <- pca_res$rotation[, 1:2]
loadings

# Create a data frame with the first two principal components
pca_df <- data.frame(pca_res$x[, 1:2])

library(tidyverse)

# Run K-means clustering
set.seed(123)
kmeans_res <- kmeans(cluster_scaled, centers = 3, nstart = 25)

# Extract cluster assignments
cluster_results <- kmeans_res$cluster

# Run PCA
pca_res <- prcomp(cluster_scaled, center = TRUE, scale. = TRUE)

# Create PCA dataframe
pca_df <- data.frame(pca_res$x[, 1:2])
colnames(pca_df) <- c("PC1", "PC2")

# Add cluster info
pca_df$Cluster <- as.factor(cluster_results)

# Plot clusters using PCA
ggplot(pca_df, aes(x = PC1, y = PC2, color = Cluster)) +
  geom_point(alpha = 0.6, size = 2) +
  labs(title = "Cluster Visualization using PCA (PC1 vs PC2)",
       x = "Principal Component 1",
       y = "Principal Component 2") +
  theme_minimal()


# Plotting clusters in two dimensions using PC1 and PC2
ggplot(pca_df, aes(x = PC1, y = PC2, color = Cluster)) +
  geom_point(alpha = 0.6, size = 2) +
  labs(title = "Cluster Visualization using PCA (PC1 vs PC2)",
       x = "Principal Component 1",
       y = "Principal Component 2") +
  theme_minimal()
# Load packages
library(factoextra)
library(ggpubr)

# Plot PCA variable contributions
fviz_pca_var(pca_res,
             col.var = "contrib",
             gradient.cols = c("skyblue", "white", "red"),
             repel = TRUE,
             title = "PCA Variable Contributions (PC1 & PC2)")
# Plotting PCA variable contributions (loadings)
fviz_pca_var(pca_res,
             col.var = "contrib",
             gradient.cols = c("skyblue", "white", "red"),
             repel = TRUE,
             title = "PCA Variable Contributions (PC1 & PC2)")

#Commentary/Findings:

# • The first two principal components explain roughly 62% of the total variance 
#   (PC1 ≈ 40%, PC2 ≈ 22%), indicating a fair reduction of dimensionality 
#   while retaining key structure in the data.

# • From the PCA variable contribution plot, PC1 is primarily driven by TotalSpend 
#   and Income, thereby suggesting that financial capacity and spending behavior 
#   dominate the main dimension of variance.

# • PC2 is influenced more by Age and Tenure, capturing a secondary pattern 
#   related to customer lifecycle and demographic maturity.

# • The PCA biplot shows clear directional separation: TotalSpend and Income 
#   vectors align closely, reaffirming their correlation observed earlier.

# • In the 2-D cluster visualization (PC1 vs PC2), two clusters are distinguishable 
#   along the PC1 axis — Cluster 1 (red) grouping lower-spend/lower-income customers, 
#   Cluster 2 (blue) representing higher-spend/higher-income segments.

# • The overlap near the center suggests mild variation within moderate-income 
#   consumers, but overall separation validates that K-means with k = 2 captures 
#   meaningful behavioral differences.
```

## 5. Cluster Profiling Interpretation

```{r section-5}

# Computing cluster means for interpretation
cluster_means <- clustered %>%
  group_by(Cluster) %>%
  summarise(across(everything(), mean, na.rm = TRUE), .groups = "drop")
cluster_means

# Cluster Profiling and Interpretation

# Cluster 1 – “Moderate-Income Family Savers”
# • Average income around $39K, relatively higher number of children (~1.3).
# • Low total spend (~$198) indicates budget-conscious, value-driven families.
# • Slightly younger (~54.6 years) with similar tenure (~12 years).
# • Likely focused on essential or family-related purchases.
# • Marketing focus: bundle offers, promotions, family discounts, loyalty incentives.

# Cluster 2 – “Affluent Empty-Nesters”
# • Higher income (~$73K), older (~58.5 years), fewer children (~0.45).
# • Spending (~$1,243) is over 6x higher, indicating luxury-oriented consumption.
# • Similar tenure (~12 years) but greater engagement in discretionary spending.
# • Marketing focus: premium positioning, experience-based rewards, personalized outreach.

# Key Insights:
# • Spending power and family composition are the main differentiators.
# • Despite similar tenure, Cluster 2 displays higher lifetime value potential.
# • Targeting strategy should reflect differing priorities - affordability vs. premium experience.

# Managerial Summary:
# • Cluster 1 = Value-driven families: focus on affordability and practicality.
# • Cluster 2 = High-value mature consumers: emphasize exclusivity and premium experiences.

```


## 6. Regression Analysis

```{r section-6}

## 6. Regression Analysis

# Creating dummy variables for clusters (Cluster 1 as baseline)
customers_reg <- clustered %>%
  mutate(Cluster = factor(Cluster))

# Running regression with TotalSpend as the dependent variable
model1 <- lm(TotalSpend ~ Cluster, data = customers_reg)
summary(model1)

# Including control variables to check robustness
model2 <- lm(TotalSpend ~ Cluster + Income + Age + Tenure + Children, data = customers_reg)
summary(model2)

# Regression Interpretation

# Model 1 (Base Model: TotalSpend ~ Cluster)
# • Cluster2 coefficient (β = 1045.48, p < 0.001) is positive and highly significant.
# • Customers in Cluster 2 spend on average about $1,045 more than Cluster 1.
# • R² = 0.718 shows that cluster membership alone explains around 72% of the variance in spending.
# • Indicates clear behavioral differentiation between clusters.

# Model 2 (Extended Model with Controls)
# • After adding controls, Cluster2 remains highly significant (β = 812.0, p < 0.001).
# • Income (β = 0.00499, p < 0.001) and Tenure (β = 10.24, p < 0.001) positively influence spending.
# • Children (β = -67.39, p < 0.001) reduces spending, while Age is not significant (p = 0.11).
# • Adjusted R² = 0.75, showing demographic factors explain 75% of spending variance.
# • Confirms that cluster segmentation captures spending behavior beyond demographics.

# Overall Interpretation
# • Cluster2 (Affluent Empty-Nesters) are significantly higher spenders than Cluster1 (Moderate-Income Family Savers).
# • Cluster effect remains robust even after controlling for demographics.
# • Regression validates clustering results: Cluster2 customers have higher purchasing power and discretionary spending.
# • Managerially, supports targeting Cluster2 with premium offers and Cluster1 with family-oriented, value-driven promotions.


```

## 7. Managerial Recommendations

```{r section-7}

# Actionable Marketing Strategies Based on Cluster & Regression Analysis

# 1. Targeted Value Promotions for Cluster 1 (Moderate-Income Family Savers)
# • Introduce family-oriented bundles and discounts to drive higher purchase frequency.
# • Offer loyalty points or cashback incentives to increase TotalSpend over time.
# • Focus messaging on affordability, practicality, and everyday utility.

# 2. Premium Loyalty and Experience Programs for Cluster 2 (Affluent Empty-Nesters)
# • Launch premium tiers or exclusive memberships with personalized perks.
# • Use personalized digital campaigns (e.g., email, app notifications) highlighting quality, exclusivity, and convenience.
# • Promote experience-driven marketing (travel, wellness, or luxury tie-ins) to enhance engagement.

# 3. Cross-Selling and Retention Campaigns Across Segments
# • Use cluster insights to tailor product recommendations and upselling strategies.
# • Design differentiated email or social media campaigns leveraging cluster-specific preferences.
# • Employ predictive analytics to anticipate churn and create customized retention offers.

# 4. Continuous Monitoring and Feedback Loop
# • Integrate clustering results into CRM systems for real-time targeting.
# • Re-run segmentation quarterly to detect behavioral shifts and adapt campaigns.
# • Combine transaction data with satisfaction or feedback metrics for holistic customer insights.

# Summary:
# • Cluster 1 = focus on value, family orientation, and practical bundles.
# • Cluster 2 = focus on premium positioning, personalization, and experience-based offers.
# • Data-driven targeting ensures higher ROI, improved customer engagement, and sustainable revenue growth.

```

## 8. AI Log

# I used Claude and Chatgpt for help with this assignment. Here is the link to chat:
https://chatgpt.com/share/6902b66a-7790-8012-a6db-abacd5df7c40
https://claude.ai/share/6b1ef825-df83-4cb8-a63e-aad3d7f17633


